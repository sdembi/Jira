name: Salesforce JIRA Integration

on:
  repository_dispatch:
    types: [jira-status-deployment-needed]

env:
  SALESFORCE_CLI_VERSION: latest
  NODE_VERSION: '18'

jobs:
  salesforce-integration:
    runs-on: ubuntu-latest
    
    steps:    
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install Salesforce CLI
      run: |
        npm install -g @salesforce/cli@${{ env.SALESFORCE_CLI_VERSION }}
        sf version      
    - name: Extract JIRA Inputs
      id: extract-inputs
      run: |
        echo "jira_ticket_key=${{ github.event.client_payload.jira_ticket_key }}" >> $GITHUB_OUTPUT
        echo "salesforce_components=${{ github.event.client_payload.salesforce_components }}" >> $GITHUB_OUTPUT
        echo "component_types=${{ github.event.client_payload.component_types }}" >> $GITHUB_OUTPUT
        echo "sandbox_org=${{ github.event.client_payload.sandbox_org }}" >> $GITHUB_OUTPUT
        echo "jira_status=${{ github.event.client_payload.jira_status }}" >> $GITHUB_OUTPUT
        
        echo "Received from JIRA:"
        echo "- Ticket: ${{ github.event.client_payload.jira_ticket_key }}"
        echo "- Status: ${{ github.event.client_payload.jira_status }}"
        echo "- Components: ${{ github.event.client_payload.salesforce_components }}"
        echo "- Types: ${{ github.event.client_payload.component_types }}"
        echo "- Sandbox: ${{ github.event.client_payload.sandbox_org }}"

    - name: Check Deployment Status
      run: |
        if [ "${{ steps.extract-inputs.outputs.jira_status }}" != "deployment needed" ]; then
          echo "Workflow triggered but status is not 'deployment needed'"
          echo "Current status: ${{ steps.extract-inputs.outputs.jira_status }}"
          echo "Exiting workflow..."
          exit 0
        fi
        echo "Status confirmed as 'deployment needed' - proceeding with deployment"

    - name: Validate Branch Name
      id: validate-branch
      run: |
        BRANCH_NAME="${{ steps.extract-inputs.outputs.jira_ticket_key }}"
        SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
        echo "branch_name=feature/$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
        echo "Branch name will be: feature/$SANITIZED_BRANCH"

    - name: Create Feature Branch
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        
        # Check if branch exists
        if git ls-remote --heads origin ${{ steps.validate-branch.outputs.branch_name }} | grep -q ${{ steps.validate-branch.outputs.branch_name }}; then
          echo "Branch ${{ steps.validate-branch.outputs.branch_name }} already exists, switching to it"
          git checkout ${{ steps.validate-branch.outputs.branch_name }}
          git pull origin ${{ steps.validate-branch.outputs.branch_name }}
        else
          echo "Creating new branch: ${{ steps.validate-branch.outputs.branch_name }}"
          git checkout -b ${{ steps.validate-branch.outputs.branch_name }}
        fi

    - name: Authenticate to Salesforce
      run: |
        echo "${{ secrets.SALESFORCE_JWT_KEY }}" > server.key        
        sf org login jwt \
          --client-id ${{ secrets.SALESFORCE_CLIENT_ID }} \
          --jwt-key-file server.key \
          --username ${{ secrets.SALESFORCE_USERNAME }} \
          --instance-url ${{ secrets.SALESFORCE_INSTANCE_URL }} \
          --alias ${{ steps.extract-inputs.outputs.sandbox_org }}
        rm server.key

    - name: Generate Package XML
      id: generate-package
      run: |
        mkdir -p force-app/main/default
        
        # Parse components and types
        COMPONENTS="${{ steps.extract-inputs.outputs.salesforce_components }}"
        TYPES="${{ steps.extract-inputs.outputs.component_types }}"
        
        cat > package.xml << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <Package xmlns="http://soap.sforce.com/2006/04/metadata">
        EOF
        
        # Convert comma-separated strings to arrays
        IFS=',' read -ra COMP_ARRAY <<< "$COMPONENTS"
        IFS=',' read -ra TYPE_ARRAY <<< "$TYPES"
        
        # Validate arrays have same length
        if [ ${#COMP_ARRAY[@]} -ne ${#TYPE_ARRAY[@]} ]; then
          echo "Error: Number of components (${#COMP_ARRAY[@]}) does not match number of types (${#TYPE_ARRAY[@]})"
          exit 1
        fi
        
        # Group components by metadata type
        declare -A TYPE_MAP
        
        for i in "${!COMP_ARRAY[@]}"; do
          comp=$(echo "${COMP_ARRAY[$i]}" | xargs)  # trim whitespace
          type=$(echo "${TYPE_ARRAY[$i]}" | xargs)  # trim whitespace
          
          # Normalize metadata type names
          case "$type" in
            "Apex Class"|"ApexClass"|"Class")
              type="ApexClass"
              ;;
            "Apex Trigger"|"ApexTrigger"|"Trigger")
              type="ApexTrigger"
              ;;
            "Custom Object"|"CustomObject"|"Object")
              type="CustomObject"
              ;;
            "Visualforce Page"|"ApexPage"|"Page")
              type="ApexPage"
              ;;
            "Visualforce Component"|"ApexComponent"|"Component")
              type="ApexComponent"
              ;;
            "Flow"|"Process")
              type="Flow"
              ;;
            "Layout"|"Page Layout")
              type="Layout"
              ;;
            "Permission Set"|"PermissionSet")
              type="PermissionSet"
              ;;
            "Custom Field"|"CustomField"|"Field")
              type="CustomField"
              ;;
            "Lightning Web Component"|"LightningComponentBundle"|"LWC")
              type="LightningComponentBundle"
              ;;
            *)
              echo "Warning: Unknown type '$type' for component '$comp', defaulting to ApexClass"
              type="ApexClass"
              ;;
          esac
          
          TYPE_MAP["$type"]+="$comp,"
        done
        
        # Generate XML for each metadata type
        for type in "${!TYPE_MAP[@]}"; do
          echo "    <types>" >> package.xml
          IFS=',' read -ra MEMBERS <<< "${TYPE_MAP[$type]}"
          for member in "${MEMBERS[@]}"; do
            if [[ -n "$member" ]]; then
              echo "        <members>$member</members>" >> package.xml
            fi
          done
          echo "        <name>$type</name>" >> package.xml
          echo "    </types>" >> package.xml
        done
        
        cat >> package.xml << 'EOF'
            <version>59.0</version>
        </Package>
        EOF
        
        echo "Generated package.xml with ${#COMP_ARRAY[@]} components:"
        cat package.xml

    - name: Retrieve Salesforce Components
      run: |
        echo "Retrieving components from ${{ steps.extract-inputs.outputs.sandbox_org }}..."
        
        sf project retrieve start \
          --manifest package.xml \
          --target-org ${{ steps.extract-inputs.outputs.sandbox_org }} \
          --wait 10
        
        echo "Retrieved components:"
        find force-app -name "*.cls" -o -name "*.trigger" -o -name "*.page" -o -name "*.component" | head -20

    - name: Commit Changes
      id: commit-changes
      run: |
        git add .
        
        if git diff --staged --quiet; then
          echo "No changes to commit"
          echo "has_changes=false" >> $GITHUB_OUTPUT        else
          git commit -m "feat: Retrieved Salesforce components for ${{ steps.extract-inputs.outputs.jira_ticket_key }}

          Components: ${{ steps.extract-inputs.outputs.salesforce_components }}
          Types: ${{ steps.extract-inputs.outputs.component_types }}
          Source Org: ${{ steps.extract-inputs.outputs.sandbox_org }}
          
          JIRA: ${{ steps.extract-inputs.outputs.jira_ticket_key }}"
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Push Feature Branch
      if: steps.commit-changes.outputs.has_changes == 'true'
      run: |
        git push origin ${{ steps.validate-branch.outputs.branch_name }}

    - name: Create Pull Request
      if: steps.commit-changes.outputs.has_changes == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Check if PR already exists
        if gh pr list --head ${{ steps.validate-branch.outputs.branch_name }} --json number --jq length | grep -q "0"; then
          gh pr create \
            --title "[${{ steps.extract-inputs.outputs.jira_ticket_key }}] Salesforce Components Update" \            
            --body "## JIRA Ticket
        **Ticket:** [${{ steps.extract-inputs.outputs.jira_ticket_key }}](https://your-jira-instance.atlassian.net/browse/${{ steps.extract-inputs.outputs.jira_ticket_key }})
        
        ## Changes
        - Retrieved Salesforce components: \`${{ steps.extract-inputs.outputs.salesforce_components }}\`
        - Component types: \`${{ steps.extract-inputs.outputs.component_types }}\`
        - Source Sandbox: \`${{ steps.extract-inputs.outputs.sandbox_org }}\`
        
        ## Components Updated
        $(find force-app -name "*.cls" -o -name "*.trigger" -o -name "*.page" -o -name "*.component" | sed 's/^/- /')
        
        ## Review Checklist
        - [ ] Code follows Salesforce best practices
        - [ ] All components compile successfully
        - [ ] Unit tests are included (if applicable)
        - [ ] Documentation is updated
        
        **Auto-generated by GitHub Actions**" \
            --head ${{ steps.validate-branch.outputs.branch_name }} \
            --base main
          
          echo "Pull Request created successfully"
        else
          echo "Pull Request already exists for this branch"
          gh pr list --head ${{ steps.validate-branch.outputs.branch_name }}
        fi

    - name: Cleanup
      if: always()
      run: |
        if [ -f "server.key" ]; then
          rm -f server.key
        fi
        if [ -f "package.xml" ]; then
          rm -f package.xml
        fi
