name: Salesforce JIRA Integration 2

on:
  repository_dispatch:
    types: [jira-status-deployment-needed]

env:
  SALESFORCE_CLI_VERSION: latest
  NODE_VERSION: '18'
  SALESFORCE_USERNAME: ${{ secrets.SALESFORCE_USERNAME }}
  SALESFORCE_CLIENT_ID: ${{ secrets.SALESFORCE_CLIENT_ID }}
  SALESFORCE_INSTANCE_URL: ${{ secrets.SALESFORCE_INSTANCE_URL }}

jobs:
  salesforce-integration:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install the SFDX CLI
        run: |
          npm install sfdx-cli --global

      - name: Setup JWT Key
        run: |
          echo "${{ secrets.SALESFORCE_JWT_KEY }}" > jwt.key
          chmod 600 jwt.key

      - name: Authenticate to Salesforce Org
        run: |
          sfdx force:auth:jwt:grant \
            --username ${{ env.SALESFORCE_USERNAME }} \
            --jwtkeyfile ./jwt.key \
            --clientid ${{ env.SALESFORCE_CLIENT_ID }} \
            --instanceurl ${{ env.SALESFORCE_INSTANCE_URL }} \
            --setdefaultusername

      - name: Show Full Payload
        run: |
          echo "Full GitHub Event Payload:"
          echo '${{ toJson(github.event) }}'
          echo ""
          echo "Client Payload Only:"
          echo '${{ toJson(github.event.client_payload) }}'

      - name: Extract JIRA Inputs
        id: extract-inputs
        run: |
          echo "jira_ticket_key=${{ github.event.client_payload.jira_ticket_key }}" >> $GITHUB_OUTPUT
          echo "salesforce_components=${{ github.event.client_payload.salesforce_components }}" >> $GITHUB_OUTPUT
          echo "component_types=${{ github.event.client_payload.component_types }}" >> $GITHUB_OUTPUT
          # echo "sandbox_org=${{ github.event.client_payload.sandbox_org }}" >> $GITHUB_OUTPUT
          echo "jira_status=${{ github.event.client_payload.jira_status }}" >> $GITHUB_OUTPUT

          echo "Received from JIRA:"
          echo "- Ticket: ${{ github.event.client_payload.jira_ticket_key }}"
          echo "- Status: ${{ github.event.client_payload.jira_status }}"
          echo "- Components: ${{ github.event.client_payload.salesforce_components }}"
          echo "- Types: ${{ github.event.client_payload.component_types }}"
          # echo "- Sandbox: ${{ github.event.client_payload.sandbox_org }}"

      - name: Check Deployment Status
        run: |
          if [ "${{ steps.extract-inputs.outputs.jira_status }}" != "deployment needed" ]; then
            echo "Workflow triggered but status is not 'deployment needed'"
            echo "Current status: ${{ steps.extract-inputs.outputs.jira_status }}"
            echo "Exiting workflow..."
            exit 0
          fi
          echo "Status confirmed as 'deployment needed' - proceeding with deployment"
        
      - name: Validate Branch Name
        id: validate-branch
        run: |
          BRANCH_NAME="${{ steps.extract-inputs.outputs.jira_ticket_key }}"
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
          echo "branch_name=feature/$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          echo "Branch name will be: feature/$SANITIZED_BRANCH"
      
      - name: Create Feature Branch
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Check if branch exists
          if git ls-remote --heads origin ${{ steps.validate-branch.outputs.branch_name }} | grep -q ${{ steps.validate-branch.outputs.branch_name }}; then
            echo "Branch ${{ steps.validate-branch.outputs.branch_name }} already exists, switching to it"
            git checkout ${{ steps.validate-branch.outputs.branch_name }}
            git pull origin ${{ steps.validate-branch.outputs.branch_name }}
          else
            echo "Creating new branch: ${{ steps.validate-branch.outputs.branch_name }}"
            git checkout -b ${{ steps.validate-branch.outputs.branch_name }}
          fi
      
      - name: Generate Package XML
        id: generate-package
        run: |
          mkdir -p force-app/main/default
          
          # Parse components and types
          COMPONENTS="${{ steps.extract-inputs.outputs.salesforce_components }}"
          TYPES="${{ steps.extract-inputs.outputs.component_types }}"
          
          cat > package.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <Package xmlns="http://soap.sforce.com/2006/04/metadata">
          EOF
          
          # Convert comma-separated strings to arrays
          IFS=',' read -ra COMP_ARRAY <<< "$COMPONENTS"
          IFS=',' read -ra TYPE_ARRAY <<< "$TYPES"
          
          # Validate arrays have same length
          if [ ${#COMP_ARRAY[@]} -ne ${#TYPE_ARRAY[@]} ]; then
            echo "Error: Number of components (${#COMP_ARRAY[@]}) does not match number of types (${#TYPE_ARRAY[@]})"
            exit 1
          fi
          
          # Group components by metadata type
          declare -A TYPE_MAP
          
          for i in "${!COMP_ARRAY[@]}"; do
            comp=$(echo "${COMP_ARRAY[$i]}" | xargs)  # trim whitespace
            type=$(echo "${TYPE_ARRAY[$i]}" | xargs)  # trim whitespace
            
            # Normalize metadata type names
            case "$type" in
              "Apex Class"|"ApexClass"|"Class")
                type="ApexClass"
                ;;
              "Apex Trigger"|"ApexTrigger"|"Trigger")
                type="ApexTrigger"
                ;;
              "Custom Object"|"CustomObject"|"Object")
                type="CustomObject"
                ;;
              "Visualforce Page"|"ApexPage"|"Page")
                type="ApexPage"
                ;;
              "Visualforce Component"|"ApexComponent"|"Component")
                type="ApexComponent"
                ;;
              "Flow"|"Process")
                type="Flow"
                ;;
              "Layout"|"Page Layout")
                type="Layout"
                ;;
              "Permission Set"|"PermissionSet")
                type="PermissionSet"
                ;;
              "Custom Field"|"CustomField"|"Field")
                type="CustomField"
                ;;
              "Lightning Web Component"|"LightningComponentBundle"|"LWC")
                type="LightningComponentBundle"
                ;;
              *)
                echo "Warning: Unknown type '$type' for component '$comp', defaulting to ApexClass"
                type="ApexClass"
                ;;
            esac
            
            TYPE_MAP["$type"]+="$comp,"
          done
          
          # Generate XML for each metadata type
          for type in "${!TYPE_MAP[@]}"; do
            echo "    <types>" >> package.xml
            IFS=',' read -ra MEMBERS <<< "${TYPE_MAP[$type]}"
            for member in "${MEMBERS[@]}"; do
              if [[ -n "$member" ]]; then
                echo "        <members>$member</members>" >> package.xml
              fi
            done
            echo "        <name>$type</name>" >> package.xml
            echo "    </types>" >> package.xml
          done
          
          cat >> package.xml << 'EOF'
              <version>59.0</version>
          </Package>
          EOF
          
          echo "Generated package.xml with ${#COMP_ARRAY[@]} components:"
          cat package.xml